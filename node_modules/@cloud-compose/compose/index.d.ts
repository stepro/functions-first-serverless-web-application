export let env: any;

export interface Properties {
    ignore?: boolean;
}

export enum SpecState {
    initial = "initial",
    defining = "defining",
    defaulting = "defaulting",
    finalizing = "finalizing",
    ready = "ready"
}

export interface AnySpec {
    readonly parent?: AnySpec;
    readonly name: string;
    readonly type: AnyType;
    readonly facets: ReadonlySet<string>;
    readonly state: SpecState;
}

export interface Spec<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties> extends AnySpec {
    readonly type: Type<T, S, P>;
    apply(properties: P): void;
}

export enum ServiceState {
    initial = "initial",
    provisioning = "provisioning",
    configuring = "configuring",
    preparing = "preparing",
    available = "available",
    unhealthy = "unhealthy",
    deprovisioning = "deprovisioning",
    deprovisioned = "deprovisioned"
}

export interface AnyService {
    readonly spec: AnySpec;
    readonly state: ServiceState;
}

export interface Service<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties> extends AnyService {
    readonly spec: S;
}

export abstract class Event {
    readonly type: string;
    readonly bubbles: boolean;
    readonly cancelable: boolean;
    readonly timestamp: Number;
    readonly phase: EventPhase;
    readonly currentTarget: AnySpec | AnyService;
    readonly defaultPrevented: boolean;
    constructor(type: string, init?: EventInit);
    stopPropagation(immediate?: boolean);
    preventDefault(): void;
}

export interface EventHandler<T extends Event> {
    (target: AnySpec | AnyService, event: T): Promise<void> | void;
}

export interface EventHandlerObject<T extends Event> {
    handleEvent: EventHandler<T>;
}

export type EventHandlerOrObject<T extends Event> = EventHandler<T> | EventHandlerObject<T>;

export type AnyEventHandlerOrObject = EventHandlerOrObject<Event>;

export interface SpecEventHandler<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> {
    (target: S, event: E): Promise<void> | void;
}

export interface SpecEventHandlerObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> extends EventHandlerObject<E> {
    handleEvent: SpecEventHandler<T, S, P, E>;
}

export declare type SpecEventHandlerOrObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> =
    SpecEventHandler<T, S, P, E> | SpecEventHandlerObject<T, S, P, E>;

export interface ServiceEventHandler<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> {
    (target: T, event: E): Promise<void> | void;
}

export interface ServiceEventHandlerObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> extends EventHandlerObject<E> {
    handleEvent: ServiceEventHandler<T, S, P, E>;
}

export type ServiceEventHandlerOrObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties, E extends Event> =
    ServiceEventHandler<T, S, P, E> | ServiceEventHandlerObject<T, S, P, E>;

export interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
}

export interface EventPhase {
    initial,
    capturing,
    atTarget,
    bubbling,
    complete
}

export interface EventTarget {
    once(type: string, listener: AnyEventHandlerOrObject, capture?: boolean): void;
    on(type: string, listener: AnyEventHandlerOrObject, capture?: boolean): void;
    off(type: string, listener: AnyEventHandlerOrObject, capture?: boolean): void;
}

export interface Selection<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties> extends EventTarget {
    apply(f: (spec: S) => P): void;
    apply(f: SpecEventHandler<T, S, P, Event>): void;
    default(f: (spec: S) => P): void;
    default(f: SpecEventHandler<T, S, P, Event>): void;
    enforce(f: (spec: S) => P): void;
    require(f: (spec: S) => boolean): void;
    finalize(f: SpecEventHandler<T, S, P, Event>): void;
    onProvision(f: ServiceEventHandler<T, S, P, Event>): void;
    onConfigure(f: ServiceEventHandler<T, S, P, Event>): void;
    onPrepare(f: ServiceEventHandler<T, S, P, Event>): void;
    afterUnhealthy(f: ServiceEventHandler<T, S, P, Event>): void;
    beforeDeprovision(f: ServiceEventHandler<T, S, P, Event>): void;
    afterDeprovision(f: ServiceEventHandler<T, S, P, Event>): void;
}

export interface Reference<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties> extends Selection<T, S, P>, Promise<T> {
    readonly name: string;
    readonly type: Type<T, S, P>;
    specValue(f: (spec: S) => any): void;
    value(f: (service: T) => any): void;
    onceAvailable(f: ServiceEventHandler<T, S, P, Event>): void;
}

export interface AnyType {
    name: string;
}

export interface Type<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Properties> extends AnyType {
    addTo(spec: CompositeSpec, name: string, properties?: P): S;
    addTo(spec: CompositeSpec, name: string, facets: string[], properties?: P): S;
    for(selector: string, within?: CompositeSpec): Selection<T, S, P>;
    (name: string): Reference<T, S, P>;
}

export interface CompositeProperties extends Properties {
    readonly services: ReadonlyMap<string, AnySpec>;
}

export interface CompositeSpec extends CompositeProperties, Spec<CompositeService, CompositeSpec, CompositeProperties> {
    select(selector: string): AnySpec[];
    spec<T extends AnySpec>(name: string): T;
}

export interface CompositeService extends Service<CompositeService, CompositeSpec, CompositeProperties> {
    readonly services: ReadonlyMap<string, AnyService>;
    select(selector: string): AnyService[];
    service<T extends AnyService>(name: string): T;
}

export interface CompositeType extends Type<CompositeService, CompositeSpec, CompositeProperties> { }

export let unit: Reference<CompositeService, CompositeSpec, CompositeProperties>;
