export enum SpecState {
    initial = "initial",
    defining = "defining",
    defaulting = "defaulting",
    finalizing = "finalizing",
    ready = "ready"
}

export interface AnySpec {
    readonly parent: AnySpec;
    readonly name: string;
    readonly facets: ReadonlySet<string>;
    readonly state: SpecState;
}

export interface Spec<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> extends AnySpec {
    apply(properties: P): void;
}

export enum ServiceState {
    initial = "initial",
    provisioning = "provisioning",
    configuring = "configuring",
    preparing = "preparing",
    available = "available",
    unhealthy = "unhealthy",
    deprovisioning = "deprovisioning",
    deprovisioned = "deprovisioned"
}

export interface AnyService {
    readonly spec: AnySpec;
    readonly state: ServiceState;
}

export interface Service<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> {
    readonly spec: S;
    readonly state: ServiceState;
}

export abstract class Event {
    readonly type: string;
    readonly bubbles: boolean;
    readonly cancelable: boolean;
    readonly timestamp: Number;
    readonly phase: EventPhase;
    readonly currentTarget: AnySpec | AnyService;
    readonly defaultPrevented: boolean;
    constructor(type: string, init?: EventInit);
    stopPropagation(immediate?: boolean);
    preventDefault(): void;
}

export interface EventHandler<T extends Event> {
    (target: AnySpec | AnyService, event: T): Promise<void> | void;
}

export interface EventHandlerObject<T extends Event> {
    handleEvent: EventHandler<T>;
}

export type EventHandlerOrObject<T extends Event> = EventHandler<T> | EventHandlerObject<T>;

export type AnyEventHandlerOrObject = EventHandlerOrObject<Event>;

export interface SpecEventHandler<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> {
    (target: S, event: E): Promise<void> | void;
}

export interface SpecEventHandlerObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> extends EventHandlerObject<E> {
    handleEvent: SpecEventHandler<T, S, P, E>;
}

export declare type SpecEventHandlerOrObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> =
    SpecEventHandler<T, S, P, E> | SpecEventHandlerObject<T, S, P, E>;

export interface ServiceEventHandler<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> {
    (target: T, event: E): Promise<void> | void;
}

export interface ServiceEventHandlerObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> extends EventHandlerObject<E> {
    handleEvent: ServiceEventHandler<T, S, P, E>;
}

export type ServiceEventHandlerOrObject<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object, E extends Event> =
    ServiceEventHandler<T, S, P, E> | ServiceEventHandlerObject<T, S, P, E>;

export interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
}

export interface EventPhase {
    initial,
    capturing,
    atTarget,
    bubbling,
    complete
}

export interface EventTarget {
    capture(type: string, listener: AnyEventHandlerOrObject): void;
    once(type: string, listener: AnyEventHandlerOrObject): void;
    on(type: string, listener: AnyEventHandlerOrObject): void;
    off(type: string, listener: AnyEventHandlerOrObject, capture?: boolean): void;
}

export interface Selection<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> extends EventTarget {
    default(f: SpecEventHandler<T, S, P, Event>): void;
    finalize(f: SpecEventHandler<T, S, P, Event>): void;
    beforeProvision(f: SpecEventHandler<T, S, P, Event>): void;
    afterProvision(f: ServiceEventHandler<T, S, P, Event>): void;
    configure(f: ServiceEventHandler<T, S, P, Event>): void;
    prepare(f: ServiceEventHandler<T, S, P, Event>): void;
    onUnhealthy(f: ServiceEventHandler<T, S, P, Event>): void;
    beforeDeprovision(f: ServiceEventHandler<T, S, P, Event>): void;
    afterDeprovision(f: ServiceEventHandler<T, S, P, Event>): void;
}

export interface Reference<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> extends Selection<T, S, P>, Promise<T> {
    define(f: SpecEventHandler<T, S, P, Event>): void;
    onAvailable(f: ServiceEventHandler<T, S, P, Event>): void;
}

export interface Type<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> {
    name: string;
    newSpec(name: string, properties?: P): S;
    newSpec(name: string, facets: string[], properties?: P): S;
    for(selector: string): Selection<T, S, P>;
    (name: string): Reference<T, S, P>;
}

export interface Spec<T extends Service<T, S, P>, S extends Spec<T, S, P> & P, P extends Object> {
    readonly type?: Type<T, S, P>;
}

export interface SpecMap {
    [name: string]: AnySpec;
}

export interface CompositeProperties {
    services?: SpecMap;
}

export interface CompositeSpec extends CompositeProperties, Spec<CompositeService, CompositeSpec, CompositeProperties>  {
}

export interface ServiceMap {
    [name: string]: AnyService;
}

export interface CompositeService extends Service<CompositeService, CompositeSpec, CompositeProperties> {
    services: ServiceMap;
}

export interface CompositeType extends Type<CompositeService, CompositeSpec, CompositeProperties> {
}

// export enum DeclaredInputType {
//     boolean = "boolean",
//     integer = "integer",
//     float = "float",
//     string = "string",
//     date = "date"
// }

// export interface DeclaredInputSet {
//     [name: string]: string | DeclaredInputSet;
// }

// export type DeclaredOutput = Promise<any>;

// export interface DeclaredOutputSet {
//     [name: string]: Promise<any> | DeclaredTypeOutputSet;
// }

// export interface DeclaredType extends CompositeType {
//     readonly inputs: DeclaredInputSet;
//     readonly outputs: DeclaredOutputSet;
//     readonly scripts: ReadonlyArray<string>;
// }

// export declare let type: DeclaredType;
