export abstract class Event {
    readonly type: string;
    readonly bubbles: boolean;
    readonly cancelable: boolean;
    readonly timestamp: Number;
    readonly phase: EventPhase;
    readonly currentTarget: ServiceSpec | Service<ServiceSpec>;
    readonly defaultPrevented: boolean;
    constructor(type: string, init?: EventInit);
    stopPropagation(immediate?: boolean);
    preventDefault(): void;
}

export interface EventHandler<T extends S | Service<S>, S extends ServiceSpec, E extends Event> {
    (target: T, event: E): Promise<void> | void;
}

export interface EventHandlerObject<T extends S | Service<S>, S extends ServiceSpec, E extends Event> {
    handleEvent: EventHandler<T, S, E>;
}

export type EventHandlerOrObject<T extends S | Service<S>, S extends ServiceSpec, E extends Event> =
    EventHandler<T, S, E> | EventHandlerObject<T, S, E>;

export interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
}

export interface EventPhase {
    initial,
    capturing,
    atTarget,
    bubbling,
    complete
}

export interface EventTarget {
    capture(type: string, listener: EventHandlerOrObject<Service<any>, any, Event>): void;
    once(type: string, listener: EventHandlerOrObject<Service<any>, any, Event>): void;
    on(type: string, listener: EventHandlerOrObject<Service<any>, any, Event>): void;
    off(type: string, listener: EventHandlerOrObject<Service<any>, any, Event>, capture?: boolean): void;
}

export enum ServiceSpecState {
    initial = "initial",
    defining = "defining",
    defaulting = "defaulting",
    finalizing = "finalizing",
    ready = "ready"
}

export interface ServiceSpec {
    readonly parent?: ServiceSpec;
    readonly name?: string;
    readonly type?: string;
    readonly facets?: ReadonlySet<string>;
    readonly state?: ServiceSpecState;
    apply(spec: ServiceSpec): void;
}

export enum ServiceState {
    initial = "initial",
    provisioning = "provisioning",
    configuring = "configuring",
    preparing = "preparing",
    available = "available",
    unhealthy = "unhealthy",
    deprovisioning = "deprovisioning",
    deprovisioned = "deprovisioned"
}

export interface Service<S extends ServiceSpec> {
    readonly parent: Service<ServiceSpec>;
    readonly spec: S;
    readonly state: ServiceState;
}

export interface Selection<T extends Service<S>, S extends ServiceSpec> extends EventTarget {
    onDefault(f: EventHandler<S, S, Event>): void;
    onFinalize(f: EventHandler<S, S, Event>): void;
    onBeforeProvision(f: EventHandler<S, S, Event>): void;
    onAfterProvision(f: EventHandler<T, S, Event>): void;
    onConfigure(f: EventHandler<T, S, Event>): void;
    onPrepare(f: EventHandler<T, S, Event>): void;
    onUnhealthy(f: EventHandler<T, S, Event>): void;
    onBeforeDeprovision(f: EventHandler<T, S, Event>): void;
    onAfterDeprovision(f: EventHandler<T, S, Event>): void;
}

export interface Reference<T extends Service<S>, S extends ServiceSpec> extends Selection<T, S>, Promise<T> {
    onDefine(f: EventHandler<S, S, Event>): void;
    onAvailable(f: EventHandler<T, S, Event>): void;
}

export interface Type<T extends Service<S>, S extends ServiceSpec> {
    name: string;
    create(name: string, facets?: string[]): S;
    for(selector: string): Selection<T, S>;
    (name: string): Reference<T, S>;
}

export interface CompositeServiceSpec extends ServiceSpec {
    services: Map<string, ServiceSpec>;
}

export interface CompositeService extends Service<CompositeServiceSpec> {
}

export interface CompositeServiceSelection extends Selection<CompositeService, CompositeServiceSpec> {
}

export interface CompositeServiceReference extends CompositeServiceSelection, Reference<CompositeService, CompositeServiceSpec> {
}

export interface CompositeType extends Type<CompositeService, CompositeServiceSpec> {
}

export interface Document extends Type<Service<ServiceSpec>, ServiceSpec> {
    readonly inputs: any;
    readonly outputs: any;
    readonly scripts: ReadonlyArray<string>;
}

export declare let document: Document;
